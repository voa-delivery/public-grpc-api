/* eslint-disable */
/*Generated by GenDocu.com*/
// package: public.v1
// file: entities.proto

import * as jspb from "google-protobuf";
import * as google_protobuf_timestamp_pb from "google-protobuf/google/protobuf/timestamp_pb";

export class Metadata extends jspb.Message {
  hasCreatedAt(): boolean;
  clearCreatedAt(): void;
  getCreatedAt(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setCreatedAt(value?: google_protobuf_timestamp_pb.Timestamp): void;

  hasUpdatedAt(): boolean;
  clearUpdatedAt(): void;
  getUpdatedAt(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setUpdatedAt(value?: google_protobuf_timestamp_pb.Timestamp): void;

  hasCanceledAt(): boolean;
  clearCanceledAt(): void;
  getCanceledAt(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setCanceledAt(value?: google_protobuf_timestamp_pb.Timestamp): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Metadata.AsObject;
  static toObject(includeInstance: boolean, msg: Metadata): Metadata.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Metadata, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Metadata;
  static deserializeBinaryFromReader(message: Metadata, reader: jspb.BinaryReader): Metadata;
}

export namespace Metadata {
  export type AsObject = {
    createdAt?: google_protobuf_timestamp_pb.Timestamp.AsObject,
    updatedAt?: google_protobuf_timestamp_pb.Timestamp.AsObject,
    canceledAt?: google_protobuf_timestamp_pb.Timestamp.AsObject,
  }
}

export class Schedule extends jspb.Message {
  getDispatchAtInMinutes(): number;
  setDispatchAtInMinutes(value: number): void;

  hasDispatchAt(): boolean;
  clearDispatchAt(): void;
  getDispatchAt(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setDispatchAt(value?: google_protobuf_timestamp_pb.Timestamp): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Schedule.AsObject;
  static toObject(includeInstance: boolean, msg: Schedule): Schedule.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Schedule, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Schedule;
  static deserializeBinaryFromReader(message: Schedule, reader: jspb.BinaryReader): Schedule;
}

export namespace Schedule {
  export type AsObject = {
    dispatchAtInMinutes: number,
    dispatchAt?: google_protobuf_timestamp_pb.Timestamp.AsObject,
  }
}

export class Courier extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getName(): string;
  setName(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Courier.AsObject;
  static toObject(includeInstance: boolean, msg: Courier): Courier.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Courier, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Courier;
  static deserializeBinaryFromReader(message: Courier, reader: jspb.BinaryReader): Courier;
}

export namespace Courier {
  export type AsObject = {
    id: string,
    name: string,
  }
}

export class History extends jspb.Message {
  hasStatus(): boolean;
  clearStatus(): void;
  getStatus(): OrderStatusMap[keyof OrderStatusMap];
  setStatus(value: OrderStatusMap[keyof OrderStatusMap]): void;

  hasEvent(): boolean;
  clearEvent(): void;
  getEvent(): OrderEventMap[keyof OrderEventMap];
  setEvent(value: OrderEventMap[keyof OrderEventMap]): void;

  hasCreatedAt(): boolean;
  clearCreatedAt(): void;
  getCreatedAt(): google_protobuf_timestamp_pb.Timestamp | undefined;
  setCreatedAt(value?: google_protobuf_timestamp_pb.Timestamp): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): History.AsObject;
  static toObject(includeInstance: boolean, msg: History): History.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: History, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): History;
  static deserializeBinaryFromReader(message: History, reader: jspb.BinaryReader): History;
}

export namespace History {
  export type AsObject = {
    status: OrderStatusMap[keyof OrderStatusMap],
    event: OrderEventMap[keyof OrderEventMap],
    createdAt?: google_protobuf_timestamp_pb.Timestamp.AsObject,
  }
}

export class Order extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  hasSource(): boolean;
  clearSource(): void;
  getSource(): Address | undefined;
  setSource(value?: Address): void;

  clearDestinationsList(): void;
  getDestinationsList(): Array<Delivery>;
  setDestinationsList(value: Array<Delivery>): void;
  addDestinations(value?: Delivery, index?: number): Delivery;

  getStatus(): OrderStatusMap[keyof OrderStatusMap];
  setStatus(value: OrderStatusMap[keyof OrderStatusMap]): void;

  getRoundTrip(): boolean;
  setRoundTrip(value: boolean): void;

  getTotal(): number;
  setTotal(value: number): void;

  clearHistoryList(): void;
  getHistoryList(): Array<History>;
  setHistoryList(value: Array<History>): void;
  addHistory(value?: History, index?: number): History;

  hasCourier(): boolean;
  clearCourier(): void;
  getCourier(): Courier | undefined;
  setCourier(value?: Courier): void;

  hasSchedule(): boolean;
  clearSchedule(): void;
  getSchedule(): Schedule | undefined;
  setSchedule(value?: Schedule): void;

  hasMetadata(): boolean;
  clearMetadata(): void;
  getMetadata(): Metadata | undefined;
  setMetadata(value?: Metadata): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Order.AsObject;
  static toObject(includeInstance: boolean, msg: Order): Order.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Order, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Order;
  static deserializeBinaryFromReader(message: Order, reader: jspb.BinaryReader): Order;
}

export namespace Order {
  export type AsObject = {
    id: string,
    source?: Address.AsObject,
    destinationsList: Array<Delivery.AsObject>,
    status: OrderStatusMap[keyof OrderStatusMap],
    roundTrip: boolean,
    total: number,
    historyList: Array<History.AsObject>,
    courier?: Courier.AsObject,
    schedule?: Schedule.AsObject,
    metadata?: Metadata.AsObject,
  }
}

export class Organization extends jspb.Message {
  getId(): string;
  setId(value: string): void;

  getName(): string;
  setName(value: string): void;

  getBalance(): number;
  setBalance(value: number): void;

  getStatus(): OrganizationStatusMap[keyof OrganizationStatusMap];
  setStatus(value: OrganizationStatusMap[keyof OrganizationStatusMap]): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Organization.AsObject;
  static toObject(includeInstance: boolean, msg: Organization): Organization.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Organization, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Organization;
  static deserializeBinaryFromReader(message: Organization, reader: jspb.BinaryReader): Organization;
}

export namespace Organization {
  export type AsObject = {
    id: string,
    name: string,
    balance: number,
    status: OrganizationStatusMap[keyof OrganizationStatusMap],
  }
}

export class Location extends jspb.Message {
  getLatitude(): number;
  setLatitude(value: number): void;

  getLongitude(): number;
  setLongitude(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Location.AsObject;
  static toObject(includeInstance: boolean, msg: Location): Location.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Location, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Location;
  static deserializeBinaryFromReader(message: Location, reader: jspb.BinaryReader): Location;
}

export namespace Location {
  export type AsObject = {
    latitude: number,
    longitude: number,
  }
}

export class Address extends jspb.Message {
  getState(): string;
  setState(value: string): void;

  getCity(): string;
  setCity(value: string): void;

  getNeighborhood(): string;
  setNeighborhood(value: string): void;

  getStreet(): string;
  setStreet(value: string): void;

  getNumber(): string;
  setNumber(value: string): void;

  hasZipCode(): boolean;
  clearZipCode(): void;
  getZipCode(): string;
  setZipCode(value: string): void;

  hasCoordinates(): boolean;
  clearCoordinates(): void;
  getCoordinates(): Location | undefined;
  setCoordinates(value?: Location): void;

  hasComplement(): boolean;
  clearComplement(): void;
  getComplement(): string;
  setComplement(value: string): void;

  hasCountry(): boolean;
  clearCountry(): void;
  getCountry(): string;
  setCountry(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Address.AsObject;
  static toObject(includeInstance: boolean, msg: Address): Address.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Address, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Address;
  static deserializeBinaryFromReader(message: Address, reader: jspb.BinaryReader): Address;
}

export namespace Address {
  export type AsObject = {
    state: string,
    city: string,
    neighborhood: string,
    street: string,
    number: string,
    zipCode: string,
    coordinates?: Location.AsObject,
    complement: string,
    country: string,
  }
}

export class Phone extends jspb.Message {
  hasDdd(): boolean;
  clearDdd(): void;
  getDdd(): string;
  setDdd(value: string): void;

  getNumber(): string;
  setNumber(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Phone.AsObject;
  static toObject(includeInstance: boolean, msg: Phone): Phone.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Phone, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Phone;
  static deserializeBinaryFromReader(message: Phone, reader: jspb.BinaryReader): Phone;
}

export namespace Phone {
  export type AsObject = {
    ddd: string,
    number: string,
  }
}

export class Document extends jspb.Message {
  getType(): DocumentTypeMap[keyof DocumentTypeMap];
  setType(value: DocumentTypeMap[keyof DocumentTypeMap]): void;

  getValue(): string;
  setValue(value: string): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Document.AsObject;
  static toObject(includeInstance: boolean, msg: Document): Document.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Document, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Document;
  static deserializeBinaryFromReader(message: Document, reader: jspb.BinaryReader): Document;
}

export namespace Document {
  export type AsObject = {
    type: DocumentTypeMap[keyof DocumentTypeMap],
    value: string,
  }
}

export class Customer extends jspb.Message {
  getName(): string;
  setName(value: string): void;

  hasPhone(): boolean;
  clearPhone(): void;
  getPhone(): Phone | undefined;
  setPhone(value?: Phone): void;

  hasEmail(): boolean;
  clearEmail(): void;
  getEmail(): string;
  setEmail(value: string): void;

  hasDocument(): boolean;
  clearDocument(): void;
  getDocument(): Document | undefined;
  setDocument(value?: Document): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Customer.AsObject;
  static toObject(includeInstance: boolean, msg: Customer): Customer.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Customer, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Customer;
  static deserializeBinaryFromReader(message: Customer, reader: jspb.BinaryReader): Customer;
}

export namespace Customer {
  export type AsObject = {
    name: string,
    phone?: Phone.AsObject,
    email: string,
    document?: Document.AsObject,
  }
}

export class Payment extends jspb.Message {
  getPrePaid(): number;
  setPrePaid(value: number): void;

  getPending(): number;
  setPending(value: number): void;

  clearWaysList(): void;
  getWaysList(): Array<PaymentWay>;
  setWaysList(value: Array<PaymentWay>): void;
  addWays(value?: PaymentWay, index?: number): PaymentWay;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Payment.AsObject;
  static toObject(includeInstance: boolean, msg: Payment): Payment.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Payment, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Payment;
  static deserializeBinaryFromReader(message: Payment, reader: jspb.BinaryReader): Payment;
}

export namespace Payment {
  export type AsObject = {
    prePaid: number,
    pending: number,
    waysList: Array<PaymentWay.AsObject>,
  }
}

export class PaymentWay extends jspb.Message {
  getValue(): number;
  setValue(value: number): void;

  getMethod(): PaymentMethodMap[keyof PaymentMethodMap];
  setMethod(value: PaymentMethodMap[keyof PaymentMethodMap]): void;

  getType(): PaymentTypeMap[keyof PaymentTypeMap];
  setType(value: PaymentTypeMap[keyof PaymentTypeMap]): void;

  hasCashChangeFor(): boolean;
  clearCashChangeFor(): void;
  getCashChangeFor(): number;
  setCashChangeFor(value: number): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): PaymentWay.AsObject;
  static toObject(includeInstance: boolean, msg: PaymentWay): PaymentWay.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: PaymentWay, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): PaymentWay;
  static deserializeBinaryFromReader(message: PaymentWay, reader: jspb.BinaryReader): PaymentWay;
}

export namespace PaymentWay {
  export type AsObject = {
    value: number,
    method: PaymentMethodMap[keyof PaymentMethodMap],
    type: PaymentTypeMap[keyof PaymentTypeMap],
    cashChangeFor: number,
  }
}

export class Delivery extends jspb.Message {
  hasCustomer(): boolean;
  clearCustomer(): void;
  getCustomer(): Customer | undefined;
  setCustomer(value?: Customer): void;

  hasAddress(): boolean;
  clearAddress(): void;
  getAddress(): Address | undefined;
  setAddress(value?: Address): void;

  hasExternalId(): boolean;
  clearExternalId(): void;
  getExternalId(): string;
  setExternalId(value: string): void;

  hasPayment(): boolean;
  clearPayment(): void;
  getPayment(): Payment | undefined;
  setPayment(value?: Payment): void;

  serializeBinary(): Uint8Array;
  toObject(includeInstance?: boolean): Delivery.AsObject;
  static toObject(includeInstance: boolean, msg: Delivery): Delivery.AsObject;
  static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
  static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
  static serializeBinaryToWriter(message: Delivery, writer: jspb.BinaryWriter): void;
  static deserializeBinary(bytes: Uint8Array): Delivery;
  static deserializeBinaryFromReader(message: Delivery, reader: jspb.BinaryReader): Delivery;
}

export namespace Delivery {
  export type AsObject = {
    customer?: Customer.AsObject,
    address?: Address.AsObject,
    externalId: string,
    payment?: Payment.AsObject,
  }
}

export interface OrderStatusMap {
  ORDER_STATUS_UNKNOWN: 0;
  ORDER_STATUS_SCHEDULED: 1;
  ORDER_STATUS_LOCATING_COURIER: 2;
  ORDER_STATUS_ON_ROUTE_TO_COLLECT: 3;
  ORDER_STATUS_AWAITING_PRODUCTION: 4;
  ORDER_STATUS_ON_ROUTE_TO_DELIVERY: 5;
  ORDER_STATUS_DELIVERED: 6;
  ORDER_STATUS_CANCELED: 7;
}

export const OrderStatus: OrderStatusMap;

export interface OrderEventMap {
  ORDER_EVENT_UNKNOWN: 0;
  ORDER_EVENT_ADDED_ROUND_TRIP: 1;
  ORDER_EVENT_REMOVED_ROUND_TRIP: 2;
  ORDER_EVENT_ADDED_DYNAMIC_FEE: 3;
  ORDER_EVENT_REMOVED_DYNAMIC_FEE: 4;
}

export const OrderEvent: OrderEventMap;

export interface OrganizationStatusMap {
  ORGANIZATION_STATUS_UNKNOWN: 0;
  ORGANIZATION_STATUS_ACTIVE: 1;
  ORGANIZATION_STATUS_INACTIVE: 2;
}

export const OrganizationStatus: OrganizationStatusMap;

export interface DocumentTypeMap {
  DOCUMENT_TYPE_UNKNOWN: 0;
  DOCUMENT_TYPE_CPF: 1;
  DOCUMENT_TYPE_CNPJ: 2;
}

export const DocumentType: DocumentTypeMap;

export interface PaymentMethodMap {
  PAYMENT_METHOD_UNKNOWN: 0;
  PAYMENT_METHOD_CARD: 1;
  PAYMENT_METHOD_CASH: 2;
  PAYMENT_METHOD_PIX: 3;
  PAYMENT_METHOD_OTHER: 4;
}

export const PaymentMethod: PaymentMethodMap;

export interface PaymentTypeMap {
  PAYMENT_TYPE_UNKNOWN: 0;
  PAYMENT_TYPE_ONLINE: 1;
  PAYMENT_TYPE_OFFLINE: 2;
}

export const PaymentType: PaymentTypeMap;

